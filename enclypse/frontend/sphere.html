<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enclypse – Presence Sphere</title>
    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <main>
      <nav>
        <a href="sphere.html" class="active">Sphere</a>
        <a href="contacts.html">Contacts</a>
        <a href="search.html">Search</a>
        <a href="chat.html">Chat</a>
        <a href="profile.html">Profile</a>
        <a href="#" id="logout-link">Logout</a>
      </nav>
      <section class="card">
        <h1>Enclypse Presence Sphere</h1>
        <p class="badge">Live map of your network</p>
        <div class="sphere-toolbar" role="group" aria-label="Sphere visibility">
          <span class="sphere-toolbar__label">Visibility</span>
          <div class="sphere-toolbar__buttons">
            <button type="button" class="sphere-toolbar__button is-active" data-visibility-mode="private" aria-pressed="true">
              Private
            </button>
            <button type="button" class="sphere-toolbar__button" data-visibility-mode="public" aria-pressed="false">
              Public
            </button>
          </div>
        </div>
        <div class="sphere-wrapper">
          <canvas id="sphere-canvas"></canvas>
        </div>
      </section>
    </main>
    <script type="module">
      import { getPresence, getContacts, connectPresenceSocket, logout, createSecretLink, api } from './common.js';

      const canvas = document.getElementById('sphere-canvas');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      const nodes = new Map();
      const avatarSprites = new Map();
      const trailLines = new Map();
      const constellationLines = new Map();
      const textureLoader = new THREE.TextureLoader();
      const themePalette = {
        default: 0x38bdf8,
        tron: 0x22d3ee,
        galaxy: 0xc084fc,
        whiteboard: 0x3b82f6,
      };

      let currentUser = null;
      let selfPreferences = {};
      let currentPreferencesMap = {};
      let latestPresencePayload = null;
      let visibilityMode = 'private';
      let friendUsernames = new Set();
      let previousOnline = new Set();
      let intersected;
      let lastPointerEvent = null;
      const linkSelection = [];
      let audioCtx;

      camera.position.z = 6;
      controls.enableDamping = true;

      const light = new THREE.PointLight(0xffffff, 1.6);
      light.position.set(5, 5, 5);
      scene.add(light);

      const ambient = new THREE.AmbientLight(0x406080, 0.5);
      scene.add(ambient);

      const sphereGeometry = new THREE.SphereGeometry(2.2, 32, 32);
      const sphereMaterial = new THREE.MeshBasicMaterial({ wireframe: true, opacity: 0.2, transparent: true, color: 0x38bdf8 });
      const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene.add(sphereMesh);

      function applyTheme(theme) {
        document.body.dataset.theme = theme || 'default';
      }

      function updateVisibilityButtons(mode) {
        document.querySelectorAll('[data-visibility-mode]').forEach((button) => {
          const isActive = button.dataset.visibilityMode === mode;
          button.classList.toggle('is-active', isActive);
          button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }

      async function loadSelf() {
        try {
          const me = await api('/api/me');
          currentUser = me.username;
          selfPreferences = me.preferences || {};
          applyTheme(selfPreferences.theme);
        } catch (error) {
          console.warn('Unable to load self preferences', error);
        }
      }

      async function loadContacts() {
        try {
          const data = await getContacts();
          friendUsernames = new Set((data.contacts || []).map((entry) => entry.username));
        } catch (error) {
          console.warn('Unable to load contacts', error);
        }
      }

      function resize() {
        const rect = renderer.domElement.getBoundingClientRect();
        renderer.setSize(rect.width || window.innerWidth * 0.8, rect.height || 500, false);
        camera.aspect = (rect.width || 1) / (rect.height || 1);
        camera.updateProjectionMatrix();
      }

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function onPointerMove(event) {
        lastPointerEvent = event;
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      }

      function highlightSelection() {
        nodes.forEach((entry, username) => {
          const selected = linkSelection.includes(username);
          entry.mesh.scale.setScalar(selected ? 1.4 : 1);
        });
      }

      function clearSelection() {
        linkSelection.length = 0;
        highlightSelection();
      }

      async function handleSecretLinkSelection(username) {
        if (!username) return;
        if (linkSelection.includes(username)) {
          clearSelection();
          return;
        }
        linkSelection.push(username);
        highlightSelection();
        if (linkSelection.length === 2) {
          const [first, second] = linkSelection;
          const label = prompt('Name this secret room', `${first} ↔ ${second}`);
          if (label) {
            const clue = prompt('Drop a hidden clue or URL');
            if (clue !== null) {
              try {
                const nonceBytes = window.crypto.getRandomValues(new Uint8Array(24));
                const nonce = btoa(String.fromCharCode(...nonceBytes));
                const cipher = btoa(unescape(encodeURIComponent(clue)));
                await createSecretLink({ label, cipher, nonce, audience: [first, second] });
                alert('Secret room anchored between nodes!');
              } catch (error) {
                alert(error.message || 'Unable to craft secret link');
              }
            }
          }
          clearSelection();
        }
      }

      function onClick(event) {
        if (!intersected) return;
        const { username } = intersected.userData || {};
        if (!username) return;
        if (event.metaKey || event.ctrlKey) {
          handleSecretLinkSelection(username);
        } else {
          window.location.href = `chat.html?to=${encodeURIComponent(username)}`;
        }
      }

      renderer.domElement.addEventListener('pointermove', onPointerMove);
      renderer.domElement.addEventListener('click', onClick);
      window.addEventListener('resize', resize);
      resize();

      function ensureAvatar(username, url) {
        const entry = nodes.get(username);
        if (!entry) return;
        if (!url) {
          const sprite = avatarSprites.get(username);
          if (sprite) {
            scene.remove(sprite);
            avatarSprites.delete(username);
          }
          return;
        }
        if (avatarSprites.has(username) && avatarSprites.get(username).userData.url === url) {
          const sprite = avatarSprites.get(username);
          sprite.position.copy(entry.mesh.position).add(new THREE.Vector3(0, 0.3, 0));
          return;
        }
        textureLoader.load(
          url,
          (texture) => {
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.45, 0.45, 0.45);
            sprite.position.copy(entry.mesh.position).add(new THREE.Vector3(0, 0.3, 0));
            sprite.userData = { url };
            avatarSprites.set(username, sprite);
            scene.add(sprite);
          },
          undefined,
          () => {
            console.warn('Failed to load avatar', url);
          },
        );
      }

      function removeMissingNodes(activeUsernames) {
        const activeSet = new Set(activeUsernames);
        nodes.forEach((entry, username) => {
          if (!activeSet.has(username)) {
            scene.remove(entry.mesh);
            entry.mesh.geometry.dispose();
            entry.mesh.material.dispose();
            nodes.delete(username);
          }
        });
        avatarSprites.forEach((sprite, username) => {
          if (!activeSet.has(username)) {
            scene.remove(sprite);
            avatarSprites.delete(username);
          }
        });
        trailLines.forEach((line, username) => {
          if (!activeSet.has(username)) {
            scene.remove(line);
            line.geometry.dispose();
            line.material.dispose();
            trailLines.delete(username);
          }
        });
      }

      function updateNodes(users) {
        const total = users.length || 1;
        users.forEach((user, idx) => {
          const paletteKey = currentPreferencesMap[user.username]?.theme || 'default';
          const baseColor = themePalette[paletteKey] || themePalette.default;
          let entry = nodes.get(user.username);
          if (!entry) {
            const geometry = new THREE.SphereGeometry(0.13, 18, 18);
            const material = new THREE.MeshStandardMaterial({ color: baseColor, emissive: baseColor, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);
            entry = { mesh };
            nodes.set(user.username, entry);
          }
          entry.mesh.material.color.setHex(baseColor);
          entry.mesh.material.emissive.setHex(baseColor);
          entry.mesh.material.emissiveIntensity = user.online ? 0.6 : 0.2;
          const phi = Math.acos(-1 + (2 * idx) / total);
          const theta = Math.sqrt(total * Math.PI) * phi;
          entry.mesh.position.set(
            2.2 * Math.cos(theta) * Math.sin(phi),
            2.2 * Math.sin(theta) * Math.sin(phi),
            2.2 * Math.cos(phi),
          );
          entry.mesh.scale.setScalar(linkSelection.includes(user.username) ? 1.4 : 1);
          entry.mesh.userData = user;
          ensureAvatar(user.username, currentPreferencesMap[user.username]?.avatar);
        });
        removeMissingNodes(users.map((u) => u.username));
      }

      function updateTrails(trails) {
        const usernames = Object.keys(trails || {});
        const activeSet = new Set(usernames);
        trailLines.forEach((line, username) => {
          if (!activeSet.has(username)) {
            scene.remove(line);
            line.geometry.dispose();
            line.material.dispose();
            trailLines.delete(username);
          }
        });
        usernames.forEach((username) => {
          const points = trails[username] || [];
          if (points.length < 2) return;
          const node = nodes.get(username);
          if (!node) return;
          const vectorPoints = points.map((point) => new THREE.Vector3(point.x, point.y, point.z));
          const geometry = new THREE.BufferGeometry().setFromPoints(vectorPoints);
          const paletteKey = currentPreferencesMap[username]?.theme || 'default';
          const color = themePalette[paletteKey] || 0x94a3b8;
          const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.35 });
          if (trailLines.has(username)) {
            const existing = trailLines.get(username);
            scene.remove(existing);
            existing.geometry.dispose();
            existing.material.dispose();
          }
          const line = new THREE.Line(geometry, material);
          scene.add(line);
          trailLines.set(username, line);
        });
      }

      function updateConstellations(constellations) {
        constellationLines.forEach((group) => {
          group.children.forEach((child) => {
            child.geometry.dispose();
            child.material.dispose();
          });
          scene.remove(group);
        });
        constellationLines.clear();
        constellations.forEach((constellation) => {
          const group = new THREE.Group();
          constellation.links.forEach((link) => {
            const fromNode = nodes.get(link.from);
            const toNode = nodes.get(link.to);
            if (!fromNode || !toNode) return;
            const geometry = new THREE.BufferGeometry().setFromPoints([
              fromNode.mesh.position.clone(),
              toNode.mesh.position.clone(),
            ]);
            const ownerTheme = currentPreferencesMap[constellation.owner]?.theme || 'default';
            const color = themePalette[ownerTheme] || 0x94a3b8;
            const material = new THREE.LineDashedMaterial({ color, transparent: true, opacity: 0.4, dashSize: 0.12, gapSize: 0.1 });
            const line = new THREE.Line(geometry, material);
            line.computeLineDistances();
            group.add(line);
          });
          scene.add(group);
          constellationLines.set(constellation.id, group);
        });
      }

      function getVisibleUsers(users) {
        if (visibilityMode === 'public') return users;
        const allowed = new Set(friendUsernames);
        if (currentUser) allowed.add(currentUser);
        return users.filter((user) => allowed.has(user.username));
      }

      function filterTrailsByVisibility(trails, allowed) {
        if (visibilityMode === 'public') return trails;
        const filtered = {};
        Object.entries(trails || {}).forEach(([username, entries]) => {
          if (allowed.has(username)) {
            filtered[username] = entries;
          }
        });
        return filtered;
      }

      function filterConstellationsByVisibility(constellations, allowed) {
        if (visibilityMode === 'public') return constellations;
        return (constellations || [])
          .filter((constellation) => allowed.has(constellation.owner))
          .map((constellation) => ({
            ...constellation,
            links: (constellation.links || []).filter((link) => allowed.has(link.from) && allowed.has(link.to)),
          }))
          .filter((constellation) => constellation.links.length > 0);
      }

      function playPresenceChime() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        const oscillator = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.12, audioCtx.currentTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.6);
        oscillator.connect(gain).connect(audioCtx.destination);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.65);
      }

      function handleChimes(users) {
        if (!selfPreferences?.soundEnabled || !selfPreferences.soundContact) return;
        const newOnline = new Set(users.filter((u) => u.online).map((u) => u.username));
        if (!previousOnline.has(selfPreferences.soundContact) && newOnline.has(selfPreferences.soundContact)) {
          playPresenceChime();
        }
        previousOnline = newOnline;
      }

      function updateScene(payload) {
        if (!payload) return;
        latestPresencePayload = payload;
        currentPreferencesMap = payload.preferences || {};
        if (currentUser && currentPreferencesMap[currentUser]?.theme && currentPreferencesMap[currentUser].theme !== selfPreferences.theme) {
          selfPreferences.theme = currentPreferencesMap[currentUser].theme;
          applyTheme(selfPreferences.theme);
        }
        const visibleUsers = getVisibleUsers(payload.users || []);
        const allowedUsernames = new Set(visibleUsers.map((user) => user.username));
        updateNodes(visibleUsers);
        updateTrails(filterTrailsByVisibility(payload.trails || {}, allowedUsernames));
        updateConstellations(filterConstellationsByVisibility(payload.constellations || [], allowedUsernames));
        handleChimes(visibleUsers);
      }

      async function loadPresence() {
        try {
          const data = await getPresence();
          updateScene(data);
        } catch (error) {
          console.error('Failed to load presence', error);
        }
      }

      connectPresenceSocket((payload) => {
        updateScene(payload);
      });

      document.querySelectorAll('[data-visibility-mode]').forEach((button) => {
        button.addEventListener('click', () => {
          const mode = button.dataset.visibilityMode;
          if (!mode || mode === visibilityMode) return;
          visibilityMode = mode;
          updateVisibilityButtons(mode);
          if (latestPresencePayload) {
            updateScene(latestPresencePayload);
          }
        });
      });
      updateVisibilityButtons(visibilityMode);

      document.getElementById('logout-link').addEventListener('click', (event) => {
        event.preventDefault();
        logout();
      });

      function animate() {
        requestAnimationFrame(animate);
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects([...nodes.values()].map((entry) => entry.mesh));
        if (intersects.length) {
          intersected = intersects[0].object;
          document.body.style.cursor = 'pointer';
        } else {
          intersected = null;
          document.body.style.cursor = 'default';
        }
        avatarSprites.forEach((sprite) => {
          sprite.position.y += Math.sin(Date.now() * 0.0015) * 0.0008;
        });
        sphereMesh.rotation.y += 0.0006;
        controls.update();
        renderer.render(scene, camera);
      }

      await loadSelf();
      await loadContacts();
      await loadPresence();
      if (latestPresencePayload) {
        updateScene(latestPresencePayload);
      }
      animate();
    </script>
  </body>
</html>
